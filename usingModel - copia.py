# -*- coding: utf-8 -*-
"""SavedModel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1q9roP9QMaZHXefFwGnBNA0T62q7hnDPD
"""

#ENTRENAR MODELO PARA GUARDARLO
#BIBLIOGRAFIA
#https://www.youtube.com/watch?v=wi6VoJcLyag
#https://data36.com/polynomial-regression-python-scikit-learn/
import pandas as pd
import numpy as np

data = pd.read_excel('/content/tabla_datos_2002.xlsx')
#guardo la data en un dataframe
target = data['ETPF56']
Y=pd.DataFrame.from_dict(target) #lo que quiero predecir
variables = data[['Mj/m2/d','TMax', 'TMin', 'PVA', 'Viento']]
X=pd.DataFrame.from_dict(variables) #las caracteristicas

#esto es para graficar...
data2 = pd.read_excel('/content/tabla_datos_segundo_semestre.xlsx')
x1 = pd.DataFrame.from_dict(data2['DiaN'])
y1 = pd.DataFrame.from_dict(data2['ETPF56']) 

#Defining the training and the test data
from sklearn.model_selection import train_test_split
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.5, shuffle = False)
#print(X_train)
#print(X_test)
X_test.to_excel('X_test.xlsx')

#StandardScaler standardizes a feature by subtracting the mean and then scaling to unit variance. Unit variance means dividing all the values by the standard deviation
from sklearn.preprocessing import StandardScaler
scale = StandardScaler()
X = scale.fit_transform(X)

from sklearn.preprocessing import PolynomialFeatures
poly = PolynomialFeatures(degree=3) #instance of PolynomialFeatures
x_poly = poly.fit_transform(X_train) #we create the new polynomial features.
poly.fit(X_train, Y_train)

#Creating a polynomial regression model
from sklearn.linear_model import LinearRegression
model = LinearRegression()
model.fit(x_poly, Y_train)

prediction = model.predict(poly.fit_transform(X_test)) # We save the predicted values our model predicts based on the previously unseen feature values (X_test).
#print(prediction)

from sklearn.metrics import mean_squared_error
poly_reg_rmse = np.sqrt(mean_squared_error(Y_test, prediction))
print(poly_reg_rmse)

import matplotlib.pyplot as plt
plt.figure(figsize=(10, 6))
plt.title("polynomial regression model", size=16)
plt.scatter(x1, y1, label = "datos reales")
plt.plot(x1, prediction, c="orange", label = "prediccion")
plt.legend()
plt.show()

import pickle
pickle.dump(model, open('model.sav', 'wb')) #writebinary

import pickle
import numpy as np
import pandas as pd
from openpyxl import Workbook
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl import load_workbook
import xlsxwriter

# El modelo fue entrenado con datos diarios y la estacion meteorologica de La Llave.. O sea con Latitud	Longitud Altura de ese departamento.
# El archivo a ingresar tiene que tener los siguientes datos:
# Temperatura máxima - Temperatura minima - Radiación en a Megajoules por día (mj/d/m) - Velocidad Promedio Viento en (m/s) - Presión de vapor de aire en (kPa)

file = '/content/LIBRO_DE_PRUEBA.xlsx'

print("Los datos a ingresar en tu archivo excel (xlsx) deben ser los siguientes: ")
print("|--------------------------------------------------------------------------------------------------------------------------------------------|")
print("|Radiacion en MJ/m²/día | Temperatura máxima | Temperatura mínima | Presión de vapor de aire actual en kPa | Vel. promedio del viento en m/s |")
print("|--------------------------------------------------------------------------------------------------------------------------------------------|")

# se carga el archivo
df1 = pd.read_excel(file)

# se carga el modelo entrenado para hacer predicciones
model = pickle.load(open('model.sav', 'rb')) #read binary
# se hace la prediccion
prediction = model.predict(poly.fit_transform(df1)) 
 
#se crea un archivo excel
wr = pd.ExcelWriter('archivo.xlsx', engine='xlsxwriter')  

print("INFO ---> una evapotranspiración de 1mm/día equivale a perder 10.000 litros de agua por hectárea en un día")
print("Para saber cuánta pérdida de agua hay por hectarea ingrese por favor el número de hectareas:")
ha= int(input())

# el ciclo for itera sobre cada preddicion de la lista prediction
df2 = pd.DataFrame()
for p in prediction:

  # se obtiene x a partir de la prediccion y la variable ha
  x = (p[0] * ha)/1
  # se redondea a dos decimales
  aguaPerdidaPorHa = np.round(x, decimals=2)
  # se crea una lista d con los valores redondeados
  d = aguaPerdidaPorHa
  # se agrega cada valor de d al dataframe df2
  df2 = df2.append({'AguaPerdida': d}, ignore_index=True)
  # se crea una columna al dataframe df1 con los valores de la lista prediccion
  df1['ETO'] = prediction

# se abre el archivo excel y se escriben los datos de df1 y df2
with pd.ExcelWriter("archivo.xlsx") as writer: 
  df1.to_excel(writer, sheet_name='Resultado', index=True)
  df2.to_excel(writer, sheet_name='Resultado', index=False, startcol=7)

print("Los resultados han sido guardado en el siguiente archivo: archivo.xlsx")

# se guardan los cambios
writer.save()
writer.close()

!pip install xlsxwriter

import argparse

# Se crea un objeto parser
parser = argparse.ArgumentParser()

# Se define el argumento opcional "--input"
parser.add_argument('--archivo', help='Nombre del archivo de entrada')

# Se parsean los argumentos de la línea de comandos
args = parser.parse_args()

# Se obtiene el nombre del archivo de entrada
input_filename = args.archivo
print(input_filename)

# Podemos abrir el archivo de entrada y procesarlo de la siguiente manera
#with open(input_filename, 'r') as input_file:
  #for line in input_file:
    # Procesamos cada línea del archivo de entrada
    #print(line.strip())

#La fórmula de la Organización de las Naciones Unidas para la Agricultura y la Alimentación (FAO) para calcular la presión de vapor actual es la siguiente: 
# pv = 0.6108 * exp(17.27 * T / (T + 237.3)) * rh
# pv es la presión de vapor actual en milibares (mb). T es la temperatura media en grados Celsiu. rh es la humedad relativa del aire en porcentaje.
# si divido por 10 obtengo kiloPascales que es lo que necesito kPa
from math import exp

T= float(input("Ingrese la temperatura media en grados Celsius: (por ejemplo: 20)"))
rhmed = float(input("Ingrese la humedad relativa media en porcentaje: (por ejemplo: 50)"))

# --> FORMULA DE LA FAO para obtener la Presion de Vapor actual en kPa
def calcular_pv(T, rhmed):
    pv = 0.6108 **(17.27 * T / (T + 237.3)) * rhmed / 10
    return pv

pv = calcular_pv(T, rhmed)
print(pv)



#convertirRadiacion = input('¿Necesitas convertir la radiacion de W/m a MJ/m²/día? (s/n) ')  
#obtenerPVA = input('¿Necesitas calcular la presión de vapor de aire? (s/n)')
#if convertirRadiacion == 's' and obtenerPVA == 's':
#  print("Leer el archivo df1 y cambiar las columnas por los valores que obtenga de los metodos")
#elif convertirRadiacion == 's' :
#  print("llamar metodo y solo cambiar la rad")
#elif obtenerPVA == 's' : 
#  print("llamar metodo y agergar la columna PVA")
#else:
 # print("Procedamos a obtener la eto y la perdida de agua")

# Se importa la librería math para utilizar la función exp
import math

# deberia recibir una lista de valores y convertirlos...........
def convertirRadiacion(watts_per_square_meter):
  # Se define la constante de conversión de megajulios a julios
  MEGAJOULE_TO_JOULE = 1000000

  # Se define la constante de conversión de segundos a días
  SECONDS_IN_DAY = 86400

  # Se define la constante de conversión de julios a watts
  JOULE_TO_WATT = 1

  # Se define la cantidad de watts por metro cuadrado a convertir
  #watts_per_square_meter = float(input("Ingrese los W/m2 a convertir: "))

  # Se calcula la presión de vapor del aire en hectopascales
  megajoules_per_square_meter_per_day = ((watts_per_square_meter * SECONDS_IN_DAY * JOULE_TO_WATT) / MEGAJOULE_TO_JOULE)

  # Se imprime el resultado
  print(f'{megajoules_per_square_meter_per_day:.2f} MJ/m²/día')